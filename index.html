<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #fafafa;
            overflow-x: auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .title {
            font-size: 4rem;
            font-weight: bold;
            color: #141416;
            margin: 0;
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: #787882;
            margin: 5px 0 20px 0;
        }
        
        .container {
            display: flex;
            gap: 30px;
            max-width: 1800px;
            margin: 0 auto;
        }
        
        .sidebar {
            flex: 0 0 400px;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        
        .section {
            margin-bottom: 25px;
        }
        
        .section h3 {
            font-size: 1.1rem;
            font-weight: bold;
            color: #141416;
            margin: 0 0 8px 0;
        }
        
        .section p {
            margin: 0 0 10px 0;
            color: #2a2a2e;
        }
        
        .legend {
            border-top: 2px solid #787882;
            padding-top: 15px;
        }
        
        .reset-button {
            background: #0064b4;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9rem;
            margin-bottom: 15px;
            margin-right: 8px;
        }
        
        .reset-button:hover {
            background: #004d8c;
        }
        
        .instructions {
            font-size: 0.8rem;
            color: #525257;
            font-style: italic;
            margin-bottom: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .legend-line {
            width: 40px;
            height: 2px;
            margin-right: 10px;
        }
        
        .diagram-container {
            flex: 1;
            position: relative;
        }
        
        #network {
            border: 1px solid #ddd;
            background: white;
            touch-action: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        /* Disable zoom */
        .diagram-container {
            overflow: hidden;
            touch-action: pan-x pan-y;
        }
        
        .node-procedural,
        .node-conceptual,
        .node-material,
        .node-philosophical {
            fill: rgba(255, 255, 255, 0.1);
            stroke: #141416;
            stroke-width: 2;
            cursor: pointer;
        }
        
        .node-engine {
            fill: rgba(255, 255, 255, 0.2);
            stroke: #141416;
            stroke-width: 3;
            cursor: pointer;
        }
        
        .node:hover {
            stroke-width: 3;
        }
        
        .node.dragging {
            stroke: #ff6b6b;
            stroke-width: 3;
        }
        
        .node-text {
            font-size: 9px;
            text-anchor: middle;
            pointer-events: none;
            font-weight: 500;
            fill: #141416;
        }
        
        .node-text-large {
            font-size: 11px;
            font-weight: bold;
        }
        
        .node-text-engine {
            font-size: 16px;
            font-weight: bold;
        }
        
        .link-procedural {
            stroke: #2864dc;
            stroke-dasharray: 5,5;
            fill: none;
            stroke-width: 1.5;
        }
        
        .link-conceptual {
            stroke: #7850c8;
            stroke-dasharray: 8,4;
            fill: none;
            stroke-width: 1.5;
        }
        
        .link-material {
            stroke: #f07800;
            stroke-dasharray: 2,3;
            fill: none;
            stroke-width: 1.5;
        }
        
        .link-philosophical {
            stroke: #14aa8c;
            stroke-dasharray: 8,4,2,4;
            fill: none;
            stroke-width: 1.5;
        }
        
        .link-connection {
            stroke: #787882;
            stroke-opacity: 0.6;
            fill: none;
            stroke-width: 1;
        }
        
        .axis-line {
            stroke: #141416;
            stroke-width: 2;
        }
        
        .axis-label {
            font-size: 14px;
            font-weight: bold;
            text-anchor: middle;
            fill: #141416;
        }
        
        .grid-line {
            stroke: #525257;
            stroke-opacity: 0.2;
            stroke-width: 1;
        }
        
        .quadrant-label {
            font-size: 13px;
            font-weight: bold;
            text-anchor: middle;
            fill: #525257;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    
    <div class="container">
        <div class="sidebar">
            <div class="section">
                <h3>Dynamic Methodology</h3>
                <p>This diagram randomly samples from my methodology framework, generating different conceptual constellations with each refresh. Each node represents a key concept or process that emerges from the recursive, materially-contingent approach to making as model-building.</p>
            </div>
            
            <div class="section">
                <h3>Framework Overview</h3>
                <p>Drawing from a recursive, materially-contingent, philosophically inhumanist framework that treats making as model-building through processes of translation, negotiation, and recombination. The emphasis shifts from predetermined outcomes to what emerges when systems, tools, and materials interact contingently.</p>
            </div>
            
            <div class="section">
                <h3>Four Registers</h3>
                <p><strong>Procedural:</strong> Seamful workflows oscillating between analogue/digital, discrete/continuous, material/computational.<br>
                <strong>Conceptual:</strong> Algorithms as open fields, seamfulness, toy/meta-modeling, contingency and plasticity.<br>
                <strong>Material:</strong> Active participants - stocks, inks, files, substrates with their own histories and behaviors.<br>
                <strong>Philosophical:</strong> Inhumanist and processual, emphasizing becoming over being, mediation between reason, matter, and technics.</p>
            </div>
            
            <div class="legend">
                <h3>Controls</h3>
                <button class="reset-button" onclick="generateNewSelection()">New Random Selection</button>
                <button class="reset-button" onclick="resetAllNodes()">Reset Layout</button>
                <button class="reset-button" onclick="exportText()">Export Arrangement</button>
                <div class="instructions">
                    • <strong>Drag nodes to position them</strong><br>
                    • "New Random Selection" generates fresh concepts<br>
                    • Double-click a node to unlock it
                </div>
                
                <h3>Legend</h3>
                <div class="legend-item">
                    <div class="legend-line" style="background: #2864dc; background-image: repeating-linear-gradient(90deg, transparent, transparent 5px, white 5px, white 10px);"></div>
                    <span>procedural workflows</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line" style="background: #7850c8; background-image: repeating-linear-gradient(90deg, transparent, transparent 8px, white 8px, white 12px);"></div>
                    <span>conceptual frameworks</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line" style="background: #f07800; background-image: repeating-linear-gradient(90deg, transparent, transparent 2px, white 2px, white 5px);"></div>
                    <span>material negotiations</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line" style="background: #14aa8c; background-image: repeating-linear-gradient(90deg, transparent, transparent 8px, white 8px, white 10px, transparent 10px, transparent 12px, white 12px, white 16px);"></div>
                    <span>philosophical orientations</span>
                </div>
                <div class="legend-item">
                    <div class="legend-line" style="background: #787882;"></div>
                    <span>model-building connections</span>
                </div>
            </div>
        </div>
        
        <div class="diagram-container">
            <svg id="network" width="1200" height="900"></svg>
            <div style="margin-top: 15px; font-size: 0.9rem; color: #525257; font-style: italic; max-width: 1200px;">
                <p><strong>Model-building as methodology:</strong> Each arrangement reveals different patterns in the recursive relationships between procedural workflows, conceptual frameworks, material negotiations, and philosophical orientations. The diagram functions as both analytical tool and generative protocol, mapping how seamful processes generate novelty through translation, negotiation, and recombination across registers.</p>
            </div>
        </div>
    </div>

    <script>
        // Methodology text corpus extracted from the provided framework
        const methodologyCorpus = [
            // Core framework
            "recursive, materially-contingent, philosophically inhumanist framework",
            "making as model-building through processes of translation, negotiation, and recombination",
            "emphasis on what emerges when systems, tools, and materials interact contingently",
            "constructing models that mediate between reason, matter, and technics",
            "art is not about representing content but about constructing mediating models",
            
            // Procedural concepts
            "recursive, multi-stage and seamful workflows",
            "processes that move between different registers: analogue to digital, discrete to continuous, material to computational",
            "recursive oscillation itself becomes the engine of methodology",
            "re-scanned film → AI augmentation → Grasshopper matrices → CNC/laser inscription → re-layered print",
            "loops of translation, re-entry, and recombination",
            "seamful workflows oscillating between registers",
            "documented processes for democratization and analysis",
            "call and response between computational instruction and material response",
            "methodology is materially dialogical",
            "protocols transparent (marginalia as open-source gestures)",
            "multi-stage workflows that resist linear pipelines",
            "procedural loops that generate recursive feedback",
            "translation between different material registers",
            "seamfulness as procedural strategy",
            "workflows that embrace rather than hide their seams",
            "re-entry as generative principle",
            "documentation as democratic protocol",
            
            // Conceptual frameworks
            "making as a form of model-building",
            "seamfulness, meta and toy modeling, contingency, and plasticity",
            "algorithms not as fixed or axiomatic rule-sets but as open fields",
            "new potentialities and novelty can surface",
            "inefficiency, waste, and residue as generative rather than obstructive",
            "toy models and metamodels as conceptual tools",
            "contingency as productive uncertainty",
            "plasticity as capacity for transformation",
            "open fields where novelty can emerge",
            "algorithms as environments rather than instructions",
            "generative potential of inefficiency",
            "waste and residue as creative materials",
            "model-building as exploratory practice",
            "contingent interactions between systems",
            "emergence over predetermined outcomes",
            "conceptual tools for navigating uncertainty",
            "metamodeling as recursive reflection",
            "toy models as experimental frameworks",
            "plasticity of form and process",
            "openness to unexpected outcomes",
            
            // Material negotiations
            "materials are never neutral supports but active participants",
            "specific materials, stocks, inks, files, and substrates all contribute their own histories, behaviours, and contingencies",
            "each transformation is not just execution but a site of negotiation",
            "material resistance and contingency are folded back into the work",
            "stocks, inks, files, substrates as active participants",
            "materials contribute their own histories and behaviors",
            "transformation as site of negotiation",
            "material resistance as creative force",
            "contingency folded back into the work",
            "scanning, tracing, reformatting, printing, cutting, varnishing as negotiations",
            "materials with their own agencies",
            "substrates as co-authors",
            "material behaviors as creative constraints",
            "files as material with their own properties",
            "inks that contribute to meaning-making",
            "stocks that carry cultural histories",
            "material dialogue rather than material control",
            "negotiation between human intention and material response",
            "material contingency as source of novelty",
            "transformation as collaborative process",
            
            // Philosophical orientations
            "inhumanist and processual orientation",
            "thinkers who emphasise becoming over being (Guattari, Negarestani, Whitehead, Parisi, Fazi, Malabou)",
            "practice located in the seams between intent, automation and contingency",
            "resist deterministic systems of authorship or proprietary craft",
            "philosophically inhumanist framework",
            "processual thinking that privileges becoming",
            "seams between intent, automation, and contingency",
            "resistance to deterministic authorship",
            "anti-proprietary approach to craft",
            "Guattari's machinic assemblages",
            "Negarestani's navigational intelligence",
            "Whitehead's process philosophy",
            "Parisi's algorithmic thought",
            "Fazi's contingent computation",
            "Malabou's destructive plasticity",
            "inhumanism as philosophical position",
            "becoming as primary ontological category",
            "automation as creative partner",
            "contingency as productive force",
            "open-source as philosophical gesture",
            "transparency as political practice",
            "marginalia as public protocol",
            "craft as collective rather than individual",
            "authorship as distributed process",
            "intelligence as navigational rather than computational",
            
            // Cross-cutting concepts
            "translation as fundamental operation",
            "negotiation between different systems",
            "recombination of elements across registers",
            "recursive feedback loops",
            "seamful integration of processes",
            "model-building as experimental practice",
            "contingent emergence of novelty",
            "plasticity across material and conceptual domains",
            "open fields of possibility",
            "generative potential of waste",
            "material-semiotic networks",
            "technical media as creative partners",
            "democratization through documentation",
            "transparency as methodological principle",
            "residue as fertilizer for future processes",
            "circulation of knowledge and techniques",
            "protocols that can be forked and adapted",
            "workflows that generate their own evolution",
            "processes that document themselves",
            "methods that resist capture by proprietary systems",
            
            // Technical processes
            "AI augmentation as translation tool",
            "Grasshopper matrices for parametric design",
            "CNC/laser inscription as material writing",
            "re-layered printing as dimensional translation",
            "re-scanning as return to digital",
            "film as analog memory medium",
            "computational tools as collaborators",
            "digital fabrication as material reasoning",
            "parametric design as open system",
            "laser cutting as precise material intervention",
            "printing as layered material construction",
            "scanning as material-to-digital translation",
            "AI as pattern recognition and generation",
            "algorithms as open-ended tools",
            "digital tools that embrace uncertainty",
            "fabrication as material computation",
            "technical media as thinking tools",
            "computational creativity through constraint",
            "digital-analog feedback loops",
            "technical workflows as conceptual frameworks",
            
            // Meta-methodological concepts
            "methodology as recursive practice",
            "framework that applies to itself",
            "model-building that models model-building",
            "recursive reflection on process",
            "methodology that evolves through use",
            "framework as living system",
            "self-documenting processes",
            "meta-analysis of creative practice",
            "recursive methodology that includes its own analysis",
            "framework that generates its own evolution",
            "model-building as both method and outcome",
            "methodology as experimental system",
            "recursive loops that include methodological reflection",
            "seamful methodology that shows its construction",
            "transparent processes that enable replication",
            "open-source methodology for creative practice",
            "framework that resists methodological capture",
            "methodology as commons rather than property",
            "recursive practice that generates new methods",
            "model-building methodology that builds methodological models"
        ];

        // Categorization function
        function categorizeChunk(chunk) {
            const procedural_keywords = ['workflow', 'process', 'loop', 'translation', 're-scan', 'augmentation', 'grasshopper', 'cnc', 'laser', 'print', 'scan', 'documentation', 'protocol'];
            const conceptual_keywords = ['model', 'algorithm', 'toy', 'meta', 'seamful', 'contingency', 'plasticity', 'open', 'field', 'novelty', 'emergence', 'framework'];
            const material_keywords = ['material', 'stock', 'ink', 'file', 'substrate', 'negotiate', 'resist', 'transform', 'scan', 'print', 'cut', 'varnish', 'dialog'];
            const philosophical_keywords = ['inhuman', 'process', 'becoming', 'guattari', 'negarestani', 'whitehead', 'parisi', 'fazi', 'malabou', 'intent', 'automation', 'seam'];
            
            const lowerChunk = chunk.toLowerCase();
            
            let scores = {
                procedural: procedural_keywords.reduce((sum, word) => sum + (lowerChunk.includes(word) ? 1 : 0), 0),
                conceptual: conceptual_keywords.reduce((sum, word) => sum + (lowerChunk.includes(word) ? 1 : 0), 0),
                material: material_keywords.reduce((sum, word) => sum + (lowerChunk.includes(word) ? 1 : 0), 0),
                philosophical: philosophical_keywords.reduce((sum, word) => sum + (lowerChunk.includes(word) ? 1 : 0), 0)
            };
            
            let maxScore = Math.max(...Object.values(scores));
            if (maxScore === 0) {
                const categories = ['procedural', 'conceptual', 'material', 'philosophical'];
                return categories[Math.floor(Math.random() * categories.length)];
            }
            
            let candidates = Object.keys(scores).filter(key => scores[key] === maxScore);
            return candidates[Math.floor(Math.random() * candidates.length)];
        }

        // Generate random selection of concepts
        function generateRandomNodes() {
            const selectedChunks = [];
            const numChunks = 18 + Math.floor(Math.random() * 8); // 18-25 concepts
            const usedIndices = new Set();
            
            while (selectedChunks.length < numChunks && usedIndices.size < methodologyCorpus.length) {
                const randomIndex = Math.floor(Math.random() * methodologyCorpus.length);
                if (!usedIndices.has(randomIndex)) {
                    usedIndices.add(randomIndex);
                    selectedChunks.push(methodologyCorpus[randomIndex]);
                }
            }
            
            const nodes = [];
            
            // Always include central engine
            nodes.push({
                id: "engine",
                label: "&",
                type: "engine",
                category: "center",
                x: 600,
                y: 450,
                fx: null,
                fy: null
            });
            
            // Create nodes from selected chunks
            selectedChunks.forEach((chunk, index) => {
                const category = categorizeChunk(chunk);
                const truncatedChunk = chunk.length > 120 ? chunk.substring(0, 117) + "..." : chunk;
                
                // Position based on category
                let x, y;
                const jitter = 180;
                
                switch(category) {
                    case 'procedural':
                        x = 300 + (Math.random() - 0.5) * jitter;
                        y = 250 + (Math.random() - 0.5) * jitter;
                        break;
                    case 'conceptual':
                        x = 900 + (Math.random() - 0.5) * jitter;
                        y = 250 + (Math.random() - 0.5) * jitter;
                        break;
                    case 'material':
                        x = 300 + (Math.random() - 0.5) * jitter;
                        y = 650 + (Math.random() - 0.5) * jitter;
                        break;
                    case 'philosophical':
                        x = 900 + (Math.random() - 0.5) * jitter;
                        y = 650 + (Math.random() - 0.5) * jitter;
                        break;
                }
                
                nodes.push({
                    id: `concept_${index}`,
                    label: truncatedChunk,
                    type: category,
                    category: category,
                    x: Math.max(50, Math.min(1150, x)),
                    y: Math.max(50, Math.min(850, y)),
                    fx: null,
                    fy: null
                });
            });
            
            return nodes;
        }

        // Generate random connections
        function generateRandomLinks(nodes) {
            const links = [];
            const conceptNodes = nodes.filter(n => n.type !== 'engine');
            
            // Connect engine to some random nodes
            const engineConnections = Math.min(5, conceptNodes.length);
            const shuffledNodes = [...conceptNodes].sort(() => 0.5 - Math.random());
            
            for (let i = 0; i < engineConnections; i++) {
                links.push({
                    source: "engine",
                    target: shuffledNodes[i].id,
                    type: "connection"
                });
            }
            
            // Create connections within categories
            const categoryGroups = {};
            conceptNodes.forEach(node => {
                if (!categoryGroups[node.type]) categoryGroups[node.type] = [];
                categoryGroups[node.type].push(node);
            });
            
            Object.keys(categoryGroups).forEach(type => {
                const nodesOfType = categoryGroups[type];
                if (nodesOfType.length > 1) {
                    const numConnections = Math.min(3, Math.floor(nodesOfType.length / 2));
                    for (let i = 0; i < numConnections; i++) {
                        const sourceIdx = Math.floor(Math.random() * nodesOfType.length);
                        let targetIdx = Math.floor(Math.random() * nodesOfType.length);
                        while (targetIdx === sourceIdx) {
                            targetIdx = Math.floor(Math.random() * nodesOfType.length);
                        }
                        
                        links.push({
                            source: nodesOfType[sourceIdx].id,
                            target: nodesOfType[targetIdx].id,
                            type: type
                        });
                    }
                }
            });
            
            // Add cross-category connections
            const numCrossConnections = Math.min(8, Math.floor(conceptNodes.length / 3));
            for (let i = 0; i < numCrossConnections; i++) {
                const sourceIdx = Math.floor(Math.random() * conceptNodes.length);
                let targetIdx = Math.floor(Math.random() * conceptNodes.length);
                while (targetIdx === sourceIdx || conceptNodes[sourceIdx].type === conceptNodes[targetIdx].type) {
                    targetIdx = Math.floor(Math.random() * conceptNodes.length);
                }
                
                links.push({
                    source: conceptNodes[sourceIdx].id,
                    target: conceptNodes[targetIdx].id,
                    type: "connection"
                });
            }
            
            return links;
        }

        // Global variables
        let currentNodes = [];
        let currentLinks = [];
        let nodeMap = {};
        
        // SVG setup
        const svg = d3.select("#network");
        const width = +svg.attr("width");
        const height = +svg.attr("height");

        // Prevent zoom behaviors
        svg.on("wheel", function(event) {
            event.preventDefault();
            event.stopPropagation();
        });
        
        svg.on("dblclick", function(event) {
            event.preventDefault();
            event.stopPropagation();
        });

        // Create main container group
        const mainGroup = svg.append("g").attr("class", "main-container");

        // Add grid
        function drawGrid() {
            const grid = mainGroup.selectAll(".grid-line").data([]);
            grid.exit().remove();
            
            const gridData = [];
            for (let x = 0; x <= width; x += 100) {
                gridData.push({type: 'vertical', pos: x});
            }
            for (let y = 0; y <= height; y += 100) {
                gridData.push({type: 'horizontal', pos: y});
            }
            
            mainGroup.selectAll(".grid-line")
                .data(gridData)
                .enter()
                .append("line")
                .attr("class", "grid-line")
                .attr("x1", d => d.type === 'vertical' ? d.pos : 0)
                .attr("y1", d => d.type === 'vertical' ? 0 : d.pos)
                .attr("x2", d => d.type === 'vertical' ? d.pos : width)
                .attr("y2", d => d.type === 'vertical' ? height : d.pos);
        }

        // Add axes and labels
        function drawAxes() {
            // Remove existing axes
            mainGroup.selectAll(".axis-line, .axis-label, .quadrant-label").remove();
            
            // Axes
            mainGroup.append("line")
                .attr("class", "axis-line")
                .attr("x1", 50).attr("y1", height/2)
                .attr("x2", width-50).attr("y2", height/2);
                
            mainGroup.append("line")
                .attr("class", "axis-line")
                .attr("x1", width/2).attr("y1", height-50)
                .attr("x2", width/2).attr("y2", 50);

            // Quadrant labels
            const labels = [
                { text: "PROCEDURAL", x: width/4, y: 30 },
                { text: "CONCEPTUAL", x: 3*width/4, y: 30 },
                { text: "MATERIAL", x: width/4, y: height-20 },
                { text: "PHILOSOPHICAL", x: 3*width/4, y: height-20 }
            ];
            
            labels.forEach(label => {
                mainGroup.append("text")
                    .attr("class", "quadrant-label")
                    .attr("x", label.x)
                    .attr("y", label.y)
                    .text(label.text);
            });
        }

        // Text wrapping function (improved version)
        function wrapText(text, maxCharsPerLine) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';
            
            for (let word of words) {
                const testLine = currentLine ? currentLine + ' ' + word : word;
                if (testLine.length <= maxCharsPerLine) {
                    currentLine = testLine;
                } else {
                    if (currentLine) lines.push(currentLine);
                    currentLine = word;
                }
            }
            if (currentLine) lines.push(currentLine);
            return lines;
        }

        // Calculate node dimensions based on text content
        function calculateNodeDimensions(nodes) {
            nodes.forEach(node => {
                const fontSize = node.type === "engine" ? 16 : 9;
                const maxCharsPerLine = node.type === "engine" ? 12 : 35;
                const lines = wrapText(node.label, maxCharsPerLine);
                
                // Calculate actual text dimensions more accurately
                const charWidth = fontSize * 0.6; // Approximate character width
                const lineHeight = fontSize * 1.2;
                
                // Find the longest line for width calculation
                const longestLineLength = Math.max(...lines.map(line => line.length));
                const textWidth = longestLineLength * charWidth;
                const textHeight = lines.length * lineHeight;
                
                // Add 20px padding (10px on each side)
                node.width = textWidth + 20;
                node.height = textHeight + 20;
                node.lines = lines;
                
                // Minimum sizes to ensure readability
                if (node.type === "engine") {
                    node.width = Math.max(node.width, 60);
                    node.height = Math.max(node.height, 40);
                } else {
                    node.width = Math.max(node.width, 80);
                    node.height = Math.max(node.height, 35);
                }
            });
        }

        // Render diagram
        function renderDiagram() {
            // Clear existing content
            mainGroup.selectAll(".link-group, .node-group").remove();
            
            drawGrid();
            drawAxes();
            
            // Calculate node dimensions based on text content
            calculateNodeDimensions(currentNodes);
            
            // Create node lookup
            nodeMap = {};
            currentNodes.forEach(node => nodeMap[node.id] = node);
            
            // Create link group
            const linkGroup = mainGroup.append("g").attr("class", "link-group");
            const links = linkGroup.selectAll("path")
                .data(currentLinks)
                .enter().append("path")
                .attr("class", d => `link-${d.type}`)
                .attr("d", d => {
                    const source = nodeMap[d.source];
                    const target = nodeMap[d.target];
                    if (source && target) {
                        const dx = target.x - source.x;
                        const dy = target.y - source.y;
                        const dr = Math.sqrt(dx * dx + dy * dy) * 1.2;
                        return `M${source.x},${source.y}A${dr},${dr} 0 0,1 ${target.x},${target.y}`;
                    }
                    return "";
                });

            // Create node group
            const nodeGroup = mainGroup.append("g").attr("class", "node-group");
            const nodes = nodeGroup.selectAll("g")
                .data(currentNodes)
                .enter().append("g")
                .attr("class", "node")
                .attr("transform", d => `translate(${d.x},${d.y})`);

            // Add squares with dynamic sizing
            nodes.append("rect")
                .attr("width", d => d.width)
                .attr("height", d => d.height)
                .attr("x", d => -d.width/2)
                .attr("y", d => -d.height/2)
                .attr("rx", 4)
                .attr("ry", 4)
                .attr("class", d => `node-${d.type}`);

            // Add text with pre-calculated wrapping
            nodes.each(function(d) {
                const node = d3.select(this);
                
                d.lines.forEach((line, i) => {
                    node.append("text")
                        .attr("class", d.type === "engine" ? "node-text node-text-engine" : "node-text")
                        .attr("y", (i - (d.lines.length-1)/2) * (d.type === "engine" ? 18 : 11))
                        .text(line);
                });
            });

            // Add drag behavior
            nodes.call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

            // Add hover and double-click
            nodes.on("mouseover", function(event, d) {
                d3.select(this).select("rect").style("stroke-width", "3px");
            })
            .on("mouseout", function(event, d) {
                d3.select(this).select("rect").style("stroke-width", null);
            })
            .on("dblclick", function(event, d) {
                event.stopPropagation();
                d.fx = null;
                d.fy = null;
                d3.select(this).select("rect")
                    .style("stroke", "#ff6b6b")
                    .transition().duration(500)
                    .style("stroke", null);
            });

            function updatePositions() {
                nodes.attr("transform", d => `translate(${d.x},${d.y})`);
                links.attr("d", d => {
                    const source = nodeMap[d.source];
                    const target = nodeMap[d.target];
                    if (source && target) {
                        const dx = target.x - source.x;
                        const dy = target.y - source.y;
                        const dr = Math.sqrt(dx * dx + dy * dy) * 1.2;
                        return `M${source.x},${source.y}A${dr},${dr} 0 0,1 ${target.x},${target.y}`;
                    }
                    return "";
                });
            }

            function dragstarted(event, d) {
                event.sourceEvent.stopPropagation();
                d.fx = d.x;
                d.fy = d.y;
                d3.select(this).classed("dragging", true);
            }

            function dragged(event, d) {
                event.sourceEvent.stopPropagation();
                d.fx = Math.max(30, Math.min(width - 30, event.x));
                d.fy = Math.max(30, Math.min(height - 30, event.y));
                d.x = d.fx;
                d.y = d.fy;
                updatePositions();
            }

            function dragended(event, d) {
                event.sourceEvent.stopPropagation();
                d3.select(this).classed("dragging", false);
                d3.select(this).select("rect")
                    .style("stroke", "#14aa8c")
                    .transition().duration(500)
                    .style("stroke", null);
            }
        }

        // Global functions
        window.generateNewSelection = function() {
            currentNodes = generateRandomNodes();
            currentLinks = generateRandomLinks(currentNodes);
            renderDiagram();
        };

        window.resetAllNodes = function() {
            currentNodes.forEach(d => {
                d.fx = null;
                d.fy = null;
                
                // Reset positions based on category
                if (d.category === "procedural") {
                    d.x = 300 + (Math.random() - 0.5) * 160;
                    d.y = 250 + (Math.random() - 0.5) * 160;
                } else if (d.category === "conceptual") {
                    d.x = 900 + (Math.random() - 0.5) * 160;
                    d.y = 250 + (Math.random() - 0.5) * 160;
                } else if (d.category === "material") {
                    d.x = 300 + (Math.random() - 0.5) * 160;
                    d.y = 650 + (Math.random() - 0.5) * 160;
                } else if (d.category === "philosophical") {
                    d.x = 900 + (Math.random() - 0.5) * 160;
                    d.y = 650 + (Math.random() - 0.5) * 160;
                } else {
                    d.x = 600;
                    d.y = 450;
                }
                
                d.x = Math.max(30, Math.min(width - 30, d.x));
                d.y = Math.max(30, Math.min(height - 30, d.y));
            });
            
            renderDiagram();
        };

        window.exportText = function() {
            try {
                const contentNodes = currentNodes.filter(d => d.type !== 'engine');
                
                const categorizeByPosition = (node) => {
                    const isLeft = node.x < width/2;
                    const isTop = node.y < height/2;
                    
                    if (isTop && !isLeft) return 'conceptual';
                    if (!isTop && !isLeft) return 'philosophical';
                    if (!isTop && isLeft) return 'material';
                    if (isTop && isLeft) return 'procedural';
                    return 'center';
                };

                const quadrantGroups = {
                    'procedural': [],
                    'conceptual': [],
                    'material': [],
                    'philosophical': []
                };

                contentNodes.forEach(node => {
                    const currentQuadrant = categorizeByPosition(node);
                    if (quadrantGroups[currentQuadrant]) {
                        quadrantGroups[currentQuadrant].push(node);
                    }
                });

                Object.keys(quadrantGroups).forEach(quadrant => {
                    quadrantGroups[quadrant].sort((a, b) => {
                        if (Math.abs(a.y - b.y) < 50) {
                            return a.x - b.x;
                        }
                        return a.y - b.y;
                    });
                });

                const quadrantNames = {
                    'procedural': 'PROCEDURAL WORKFLOWS',
                    'conceptual': 'CONCEPTUAL FRAMEWORKS',
                    'material': 'MATERIAL NEGOTIATIONS',
                    'philosophical': 'PHILOSOPHICAL ORIENTATIONS'
                };

                let textContent = "IT IS ONLY WHAT IT DOES: RECURSIVE METHODOLOGY ARRANGEMENT\n";
                textContent += "=" + "=".repeat(70) + "\n\n";
                textContent += "Current arrangement of methodology concepts as positioned in the diagram.\n\n";

                const quadrantOrder = ['procedural', 'conceptual', 'material', 'philosophical'];
                
                quadrantOrder.forEach(quadrant => {
                    const quadrantNodes = quadrantGroups[quadrant];
                    
                    textContent += quadrantNames[quadrant] + "\n";
                    textContent += "-".repeat(quadrantNames[quadrant].length) + "\n";
                    
                    if (quadrantNodes.length > 0) {
                        textContent += `(${quadrantNodes.length} concepts arranged in this quadrant)\n\n`;
                        
                        quadrantNodes.forEach((node, index) => {
                            const cleanText = node.label.replace(/\n/g, ' ').replace(/\s+/g, ' ').trim();
                            textContent += `${index + 1}. ${cleanText}\n\n`;
                        });
                    } else {
                        textContent += "(No concepts currently positioned in this quadrant)\n\n";
                    }
                    
                    textContent += "\n";
                });

                const currentDate = new Date().toLocaleDateString();
                const currentTime = new Date().toLocaleTimeString();
                textContent += "\n" + "-".repeat(70) + "\n";
                textContent += `Methodology arrangement exported on ${currentDate} at ${currentTime}\n`;

                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                const blob = new Blob([textContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `methodology_arrangement_${timestamp}.txt`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Visual feedback
                const button = event.target;
                if (button) {
                    const originalText = button.textContent;
                    button.textContent = 'Exported!';
                    button.style.background = '#14aa8c';
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.background = '#0064b4';
                    }, 2000);
                }
            } catch (error) {
                console.error('Export error:', error);
                alert('Export failed. Check console for details.');
            }
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            generateNewSelection();
        });

        // Prevent zoom on document
        document.addEventListener('wheel', function(e) {
            if (e.target.closest('#network')) {
                e.preventDefault();
            }
        }, { passive: false });
    </script>
</body>
</html>
